// Expanded form of the Mongo query parsing script found in https://github.com/cloudhubs/source-code-parser/blob/main/ressa_examples/deathstarbench_ressa_entity.json

fn valid_ndx(tokens, ndx) {
    0 <= ndx && ndx < tokens.len()
}

fn handle_attribute(parent, tokens, ndx, ctx, name, isCollection) {
    let newParent = if parent.contains_key(name) { parent[name] } else { #{} };
    if newParent.contains_key("") {
        newParent[""].isCollection = isCollection || newParent[""].isCollection;
    } else {
        newParent[""] = #{ "isCollection": isCollection };
    }
    let tuple = choose_action(newParent, tokens, ndx + 2, ctx);
    parent[name] = tuple.0;
    (parent, tuple.1)
}

fn handle_dollar(parent, tokens, ndx, ctx) {
    if !valid_ndx(tokens, ndx + 1) { return (parent, ndx); }
    match tokens[ndx] {
        "$pull" => handle_attribute(parent, tokens, ndx + 2, ctx, tokens[ndx + 2], true),
        "$push" => handle_attribute(parent, tokens, ndx + 2, ctx, tokens[ndx + 2], true),
        "$elemMatch" => {
            parent[""].isCollection = true;
            choose_action(parent, tokens, ndx + 1, ctx)
        }
        _ => choose_action(parent, tokens, ndx + 1, ctx)
    }
}

fn handle_name(parent, tokens, ndx, ctx) {
    if !valid_ndx(tokens, ndx + 1) { return (parent, ndx); }
    let name = tokens[ndx];
    if name == "}" { return (parent, ndx); }
    else if name == "projection" { return (parent, tokens.len() + 1) }
    match tokens[ndx + 1] {
        "{" => handle_attribute(parent, tokens, ndx, ctx, name, false),
        "[" => handle_attribute(parent, tokens, ndx, ctx, name, true),
        "}" => (parent, ndx + 1),
        "]" => (parent, ndx + 1),
        literal => {
            if literal.starts_with("$") {
                handle_dollar(parent, tokens, ndx, ctx)
            } else {
                parent[name] = tokens[ndx + 1];
                handle_name(parent, tokens, ndx + 2, ctx)
            }
        }
    }
}

fn choose_action(parent, tokens, ndx, ctx) {
    if !valid_ndx(tokens, ndx) { return parent; }
    match tokens[ndx] {
        "{" => choose_action(parent, tokens, ndx + 1, ctx),
        "[" => choose_action(parent, tokens, ndx + 1, ctx),
        "}" => (parent, ndx + 1),
        "]" => (parent, ndx + 1),
        token => {
            if token.starts_with("$") {
                handle_dollar(parent, tokens, ndx, ctx)
            } else {
                handle_name(parent, tokens, ndx, ctx)
            }
        }
    }
}

fn start(parent, tokens, ctx) {
    let ndx = 0;
    while valid_ndx(tokens, ndx) {
        let tuple = choose_action(parent, tokens, ndx, ctx);
        parent = tuple.0;
        ndx = tuple.1;
    }
    parent
}

fn cleanup(ctx) {
    ctx.save("tokens", #{ "vec": [] });
}

let tokens = ctx.get("tokens")?.vec;
let coll = ctx.get_variable("collection_name")?;
let collectionObj = ctx.get_or_save(coll, #{});
match tokens.get(0) {
    Some(token) => {
        let result = start(collectionObj, tokens, ctx);
        ctx.save(coll, result);
        tokens.clear();
    }
    _ => {
        tokens.clear();
        panic("No tokens");
    }
}
